// Generated by 'gc gencode'
const {} = require("rubico");
const {} = require("rubico/x");

exports.createResources = () => [
  {
    type: "GraphqlApi",
    group: "AppSync",
    name: "My AppSync App",
    properties: ({}) => ({
      authenticationType: "API_KEY",
      xrayEnabled: false,
      apiKeys: [{}],
      schemaFile: "My AppSync App.graphql",
    }),
  },
  {
    type: "DataSource",
    group: "AppSync",
    name: "MyModelTypeTable",
    properties: ({ config }) => ({
      description: "DynamoDB table backing the MyModelType object type.",
      type: "AMAZON_DYNAMODB",
      dynamodbConfig: {
        awsRegion: `${config.region}`,
        tableName: "MyModelTypeTable",
        useCallerCredentials: false,
        versioned: false,
      },
    }),
    dependencies: ({}) => ({
      graphqlApi: "My AppSync App",
      serviceRole: "appsync-ds-ddb-f7ekj4-MyModelTypeTable",
      dynamoDbTable: "MyModelTypeTable",
    }),
  },
  {
    type: "Resolver",
    group: "AppSync",
    properties: ({}) => ({
      typeName: "Mutation",
      fieldName: "createMyModelType",
      requestMappingTemplate:
        '{\n  "version": "2017-02-28",\n  "operation": "PutItem",\n  "key": {\n    "id": $util.dynamodb.toDynamoDBJson($util.autoId()),\n  },\n  "attributeValues": $util.dynamodb.toMapValuesJson($ctx.args.input),\n  "condition": {\n    "expression": "attribute_not_exists(#id)",\n    "expressionNames": {\n      "#id": "id",\n    },\n  },\n}',
      responseMappingTemplate: "$util.toJson($context.result)",
      kind: "UNIT",
    }),
    dependencies: ({}) => ({
      graphqlApi: "My AppSync App",
      dataSource: "MyModelTypeTable",
    }),
  },
  {
    type: "Resolver",
    group: "AppSync",
    properties: ({}) => ({
      typeName: "Mutation",
      fieldName: "deleteMyModelType",
      requestMappingTemplate:
        '{\n  "version": "2017-02-28",\n  "operation": "DeleteItem",\n  "key": {\n    "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),\n  },\n}',
      responseMappingTemplate: "$util.toJson($context.result)",
      kind: "UNIT",
    }),
    dependencies: ({}) => ({
      graphqlApi: "My AppSync App",
      dataSource: "MyModelTypeTable",
    }),
  },
  {
    type: "Resolver",
    group: "AppSync",
    properties: ({}) => ({
      typeName: "Mutation",
      fieldName: "updateMyModelType",
      requestMappingTemplate:
        '{\n  "version": "2017-02-28",\n  "operation": "UpdateItem",\n  "key": {\n    "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),\n  },\n\n  ## Set up some space to keep track of things we\'re updating **\n  #set( $expNames  = {} )\n  #set( $expValues = {} )\n  #set( $expSet = {} )\n  #set( $expAdd = {} )\n  #set( $expRemove = [] )\n\n  ## Iterate through each argument, skipping keys **\n  #foreach( $entry in $util.map.copyAndRemoveAllKeys($ctx.args.input, ["id"]).entrySet() )\n    #if( $util.isNull($entry.value) )\n      ## If the argument is set to "null", then remove that attribute from the item in DynamoDB **\n\n      #set( $discard = ${expRemove.add("#${entry.key}")} )\n      $!{expNames.put("#${entry.key}", "${entry.key}")}\n    #else\n      ## Otherwise set (or update) the attribute on the item in DynamoDB **\n\n      $!{expSet.put("#${entry.key}", ":${entry.key}")}\n      $!{expNames.put("#${entry.key}", "${entry.key}")}\n      $!{expValues.put(":${entry.key}", $util.dynamodb.toDynamoDB($entry.value))}\n    #end\n  #end\n\n  ## Start building the update expression, starting with attributes we\'re going to SET **\n  #set( $expression = "" )\n  #if( !${expSet.isEmpty()} )\n    #set( $expression = "SET" )\n    #foreach( $entry in $expSet.entrySet() )\n      #set( $expression = "${expression} ${entry.key} = ${entry.value}" )\n      #if ( $foreach.hasNext )\n        #set( $expression = "${expression}," )\n      #end\n    #end\n  #end\n\n  ## Continue building the update expression, adding attributes we\'re going to ADD **\n  #if( !${expAdd.isEmpty()} )\n    #set( $expression = "${expression} ADD" )\n    #foreach( $entry in $expAdd.entrySet() )\n      #set( $expression = "${expression} ${entry.key} ${entry.value}" )\n      #if ( $foreach.hasNext )\n        #set( $expression = "${expression}," )\n      #end\n    #end\n  #end\n\n  ## Continue building the update expression, adding attributes we\'re going to REMOVE **\n  #if( !${expRemove.isEmpty()} )\n    #set( $expression = "${expression} REMOVE" )\n\n    #foreach( $entry in $expRemove )\n      #set( $expression = "${expression} ${entry}" )\n      #if ( $foreach.hasNext )\n        #set( $expression = "${expression}," )\n      #end\n    #end\n  #end\n\n  ## Finally, write the update expression into the document, along with any expressionNames and expressionValues **\n  "update": {\n    "expression": "${expression}",\n    #if( !${expNames.isEmpty()} )\n      "expressionNames": $utils.toJson($expNames),\n    #end\n    #if( !${expValues.isEmpty()} )\n      "expressionValues": $utils.toJson($expValues),\n    #end\n  },\n\n  "condition": {\n    "expression": "attribute_exists(#id)",\n    "expressionNames": {\n      "#id": "id",\n    },\n  }\n}',
      responseMappingTemplate: "$util.toJson($context.result)",
      kind: "UNIT",
    }),
    dependencies: ({}) => ({
      graphqlApi: "My AppSync App",
      dataSource: "MyModelTypeTable",
    }),
  },
  {
    type: "Resolver",
    group: "AppSync",
    properties: ({}) => ({
      typeName: "Query",
      fieldName: "getMyModelType",
      requestMappingTemplate:
        '{\n  "version": "2017-02-28",\n  "operation": "GetItem",\n  "key": {\n    "id": $util.dynamodb.toDynamoDBJson($ctx.args.id),\n  },\n}',
      responseMappingTemplate: "$util.toJson($context.result)",
      kind: "UNIT",
    }),
    dependencies: ({}) => ({
      graphqlApi: "My AppSync App",
      dataSource: "MyModelTypeTable",
    }),
  },
  {
    type: "Resolver",
    group: "AppSync",
    properties: ({}) => ({
      typeName: "Query",
      fieldName: "listMyModelTypes",
      requestMappingTemplate:
        '{\n  "version": "2017-02-28",\n  "operation": "Scan",\n  "filter": #if($context.args.filter) $util.transform.toDynamoDBFilterExpression($ctx.args.filter) #else null #end,\n  "limit": $util.defaultIfNull($ctx.args.limit, 20),\n  "nextToken": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null)),\n}',
      responseMappingTemplate: "$util.toJson($context.result)",
      kind: "UNIT",
    }),
    dependencies: ({}) => ({
      graphqlApi: "My AppSync App",
      dataSource: "MyModelTypeTable",
    }),
  },
  {
    type: "MetricAlarm",
    group: "CloudWatch",
    properties: ({ config, getId }) => ({
      AlarmName: "alarm-graphql-400",
      AlarmActions: [
        `arn:aws:sns:${
          config.region
        }:${config.accountId()}:Default_CloudWatch_Alarms_Topic`,
      ],
      MetricName: "4XXError",
      Namespace: "AWS/AppSync",
      Statistic: "Average",
      Dimensions: [
        {
          Value: `${getId({
            type: "GraphqlApi",
            group: "AppSync",
            name: "My AppSync App",
          })}`,
          Name: "GraphQLAPIId",
        },
      ],
      Period: 300,
      EvaluationPeriods: 1,
      DatapointsToAlarm: 1,
      Threshold: 2,
      ComparisonOperator: "GreaterThanThreshold",
      TreatMissingData: "missing",
    }),
    dependencies: ({}) => ({
      snsTopic: "Default_CloudWatch_Alarms_Topic",
      appSyncGraphqlApi: "My AppSync App",
    }),
  },
  {
    type: "Table",
    group: "DynamoDB",
    properties: ({}) => ({
      TableName: "MyModelTypeTable",
      AttributeDefinitions: [
        {
          AttributeName: "id",
          AttributeType: "S",
        },
      ],
      KeySchema: [
        {
          AttributeName: "id",
          KeyType: "HASH",
        },
      ],
      BillingMode: "PAY_PER_REQUEST",
    }),
  },
  {
    type: "Role",
    group: "IAM",
    name: "appsync-ds-ddb-f7ekj4-MyModelTypeTable",
    properties: ({}) => ({
      Description: "Allows the AWS AppSync service to access your data source.",
      Path: "/service-role/",
      AssumeRolePolicyDocument: {
        Version: "2012-10-17",
        Statement: [
          {
            Effect: "Allow",
            Principal: {
              Service: `appsync.amazonaws.com`,
            },
            Action: "sts:AssumeRole",
          },
        ],
      },
    }),
    dependencies: ({}) => ({
      policies: ["appsync-ds-ddb-f7ekj4-MyModelTypeTable"],
    }),
  },
  {
    type: "Policy",
    group: "IAM",
    name: "appsync-ds-ddb-f7ekj4-MyModelTypeTable",
    properties: ({ getId }) => ({
      PolicyDocument: {
        Version: "2012-10-17",
        Statement: [
          {
            Effect: "Allow",
            Action: [
              "dynamodb:DeleteItem",
              "dynamodb:GetItem",
              "dynamodb:PutItem",
              "dynamodb:Query",
              "dynamodb:Scan",
              "dynamodb:UpdateItem",
            ],
            Resource: [
              `${getId({
                type: "Table",
                group: "DynamoDB",
                name: "MyModelTypeTable",
              })}`,
              `${getId({
                type: "Table",
                group: "DynamoDB",
                name: "MyModelTypeTable",
              })}/*`,
            ],
          },
        ],
      },
      Path: "/service-role/",
    }),
    dependencies: ({}) => ({
      table: "MyModelTypeTable",
    }),
  },
  {
    type: "Topic",
    group: "SNS",
    name: "Default_CloudWatch_Alarms_Topic",
    properties: ({}) => ({
      Attributes: {
        DisplayName: "",
        DeliveryPolicy: {
          http: {
            defaultHealthyRetryPolicy: {
              minDelayTarget: 20,
              maxDelayTarget: 20,
              numRetries: 3,
              numMaxDelayRetries: 0,
              numNoDelayRetries: 0,
              numMinDelayRetries: 0,
              backoffFunction: "linear",
            },
            disableSubscriptionOverrides: false,
          },
        },
      },
    }),
  },
];
